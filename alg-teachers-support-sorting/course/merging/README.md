# Теоретический вопрос
Какой из алгоритмов сортировки, вставками, быстрая сортировка, сортировка слиянием, сортировка подсчетом или timsort, будет наиболее эффективным в следующей ситуации:
Когда у вас есть массив из 100 элементов, и он уже отсортирован в обратном порядке.

Выберите один ответ:
1. Timsort
2. Сортировка подсчётом
3. Быстрая сортировка
4. Сортировка слиянием (ВЕРНО)
5. Сортировка вставками

# Задача №1

Имеется массив данных для сортировки int arr[] размера n (1<n)

Необходимо отсортировать его методом сортировки слиянием по возрастанию, при этом обязательно необходимо выводить разделение на подмассивы, разделять нужно только пробелом (смотри пример)


### Примечание:

Нельзя пользоваться готовыми библиотечными функциями для сортировки, нужно сделать реализацию сортировки вручную.



## Формат входа. 

Первая строка содержит натуральное число n - размерность массива, следующая строка содержит элементы массива через пробел.

## Формат выхода.

В каждой строчке располагаются разделённые подмассивы с пометкой "Merging arr: "
В последней строчке отсортированный массив с пометкой "Answer: "



## Пример.
### Вход:

7

7 4 2 1 0 5 3

### Выход:

Merging arr: 7 4 2 1 0 5 3

Merging arr: 7 4 2 1

Merging arr: 7 4

Merging arr: 2 1

Merging arr: 0 5 3

Merging arr: 0 5

Answer: 0 1 2 3 4 5 7



## Пояснение: (!!!)

![Explanation](https://github.com/moevm/alg-teachers-support/blob/sorting/course/merging/3_task_example_and_explain.png)



# Задача №2

Имеется массив данных для сортировки int arr[] размера n (1<n)

Необходимо отсортировать его методом сортировки слиянием по следующему критерию: сортировка по наибольшему соседнему элементу по убыванию, при этом обязательно необходимо выводить разделение на подмассивы, разделять нужно только пробелом (смотри пример)


### Примечание:

Нельзя пользоваться готовыми библиотечными функциями для сортировки, нужно сделать реализацию сортировки вручную.

Для первого и последнего элемента считаем соседним элементом только значение следующего и предыдущего элемента соответственно.



## Формат входа. 

Первая строка содержит натуральное число n - размерность массива, следующая строка содержит элементы массива через пробел.

## Формат выхода.

В каждой строчке располагаются разделённые подмассивы с пометкой "Merging arr: "
В последней строчке отсортированный массив с пометкой "Answer: "



## Пример.
### Вход:

7

7 4 -10 6 2 3 5

### Выход:

Merging arr: 7 4 -10 6 2 3 5

Merging arr: 7 4 -10 6

Merging arr: 7 4

Merging arr: -10 6

Merging arr: 2 3 5

Merging arr: 2 3

Answer: 4 -10 2 3 7 5 6



## Пояснение примера:


В примере у нас дан массив [7 4 -10 6 2 3 5], назовём его input.
Сортировка происходит по наибольшему соседнему элементу по убыванию, поэтому можно сформировать следующий массив, назовём его comp_input:

Для 0 элемента 7: 4
Для 1 элемента 4: 7 > -10 => 7
Для 2 элемента -10:  4 < 6 => 6 
Для 3 элемента 6: -10 < 2 => 2
Для 4 элемента 2: 6 > 3 => 6
Для 5 элемента 3: 2 < 5 =>5
Для 6 элемента 5: 3

Следовательно полученный массив будет таким: [4 7 6 2 6 5 3], его и необходимо отсортировать, получаем: [7 6 6 5 4 3 2]
Однако необходимо выводить разделение на подмассивы не массива comp_input, а именно массива input, опираясь на значения массива comp_input. 
Именно поэтому результатом сортировки будет являться отсортированный массив input, а именно [4 -10 2 3 7 5 6]. 

Пошаговый вывод разделения на подмассивы точно также должен содержать разделение именно массива input.