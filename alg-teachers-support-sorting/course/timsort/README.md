# Теоретический вопрос
Какой из алгоритмов сортировки, вставками, быстрая сортировка, сортировка слиянием, сортировка подсчетом или timsort, будет наиболее эффективным в следующей ситуации:
Когда у вас есть массив из 100 000 элементов, и большинство элементов находятся на своих местах, но есть некоторые дублирующиеся элементы

Выберите один ответ:
1. Timsort (ВЕРНО)
2. Сортировка подсчётом
3. Быстрая сортировка
4. Сортировка слиянием
5. Сортировка вставками

# Задача №1

Имеется массив данных для сортировки int arr[] размера n

Необходимо отсортировать его алгоритмом сортировки Timsort по возрастанию.
Так как Timsort - это гибридный алгоритм, содержащий в себе сортировку слиянием и сортировку вставками, то вам предстоит использовать оба этих алгоритма. Поэтому нужно выводить разделённые блоки, которые уже отсортированы сортировкой вставками.


### Примечание:

Нельзя пользоваться готовыми библиотечными функциями для сортировки, нужно сделать реализацию сортировки вручную.

0 < n < 65

Обратите внимание на пример. (min_run = 32)




## Формат входа. 

Первая строка содержит натуральное число n - размерность массива, следующая строка содержит элементы массива через пробел.

## Формат выхода.

Выводятся разделённые блоки для сортировки в формате "Part i: *отсортированный разделённый массив*"

Последняя строчка содержит финальный результат сортировки массива с надписью "Answer: "


## Пример #1.

### Вход:

40

-14 77 15 93 35 86 -8 -51 -79 62 -73 -10 -41 63 26 40 -74 72 36 -89 68 67 -71 82 30 -38 23 -33 35 29 -98 -78 -42 -31 67 93 -44 -89 -58 -71 

### Выход:

Part 0: -98 -89 -79 -78 -74 -73 -71 -51 -41 -38 -33 -14 -10 -8 15 23 26 29 30 35 35 36 40 62 63 67 68 72 77 82 86 93 

Part 1: -89 -71 -58 -44 -42 -31 67 93 

Answer: -98 -89 -89 -79 -78 -74 -73 -71 -71 -58 -51 -44 -42 -41 -38 -33 -31 -14 -10 -8 15 23 26 29 30 35 35 36 40 62 63 67 67 68 72 77 82 86 93 93



## Пример #2.

### Вход:

5

4 3 5 1 2

### Выход:

Part 0: 1 2 3 4 5

Answer: 1 2 3 4 5


# Задача №2

Имеется массив данных для сортировки int arr[] размера n

Необходимо отсортировать его алгоритмом сортировки Timsort по следующему критерию: по наименьшему значению квадрата элемента (в случае равенства значений элементов в квадрате - сортировка происходит по убыванию).
Так как Timsort - это гибридный алгоритм, содержащий в себе сортировку слиянием и сортировку вставками, то вам предстоит использовать оба этих алгоритма. Поэтому нужно выводить разделённые блоки, которые уже отсортированы сортировкой вставками.


### Примечание:

Нельзя пользоваться готовыми библиотечными функциями для сортировки, нужно сделать реализацию сортировки вручную.

0 < n < 65

Обратите внимание на пример. (min_run = 32)



## Формат входа. 

Первая строка содержит натуральное число n - размерность массива, следующая строка содержит элементы массива через пробел.

## Формат выхода.

Выводятся разделённые блоки для сортировки в формате "Part i: *отсортированный разделённый массив*"

Последняя строчка содержит финальный результат сортировки массива с надписью "Answer: "

## Пример #1.

### Вход:

44

-4 7 5 3 5 -4 2 -1 -9 -8 -3 0 9 -7 -4 -10 -4 2 6 1 -2 -3 -1 -8 0 -8 -7 -3 5 -1 -8 -8 8 -1 -3 3 6 1 -8 -1 3 -9 9 -6 

### Выход:

Part 0: 0 0 1 -1 -1 -1 2 2 -2 3 -3 -3 -3 -4 -4 -4 -4 5 5 5 6 7 -7 -7 -8 -8 -8 -8 -8 9 -9 -10 

Part 1: 1 -1 -1 3 3 -3 6 -6 8 -8 9 -9 

Answer: 0 0 1 1 -1 -1 -1 -1 -1 2 2 -2 3 3 3 -3 -3 -3 -3 -4 -4 -4 -4 5 5 5 6 6 -6 7 -7 -7 8 -8 -8 -8 -8 -8 -8 9 9 -9 -9 -10 



## Пример #2.

### Вход:

19

-5 -1 6 -6 0 -4 7 -2 -2 9 -2 -10 5 8 3 2 2 8 9

### Выход:

Part 0: 0 -1 2 2 -2 -2 -2 3 -4 5 -5 6 -6 7 8 8 9 9 -10 

Answer: 0 -1 2 2 -2 -2 -2 3 -4 5 -5 6 -6 7 8 8 9 9 -10
